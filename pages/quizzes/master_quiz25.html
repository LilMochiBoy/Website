<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Challenger Quiz Level 25: Review</title>
	<link rel="stylesheet" href="../../assets/css/style.css">
	<style>
	/* Make quiz page fit viewport and remove vertical scrolling */
	html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
	body { display: flex; flex-direction: column; align-items: center; justify-content: flex-start; }

	/* Tighter header */
	.duo-header { margin-top: 12px; margin-bottom: 8px; }
	.duo-img { width: 48px; height: 48px; }
	.duo-title { font-size: 1.6rem; }

	/* Reduce large spacings so content fits without scroll */
	.quiz-question { margin: 24px 0 16px 0; margin-bottom: 24px; font-size: 1.4rem; max-width: 92vw; }
	.quiz-answers { gap: 12px; margin-top: 20px; margin-bottom: 8px; width: calc(100vw - 32px); padding-left: 16px; padding-right: 16px; max-width: 900px; }
	.answer-btn-custom { padding: 12px 10px; font-size: 1.05rem; min-height: 52px; }

	/* Progress and HUD spacing */
	.quiz-progress { margin: 8px auto 0 auto; width: 90%; }
	.quiz-progress-bar { height: 14px; }

	/* Boss image: remove rounded box/box-shadow and make background transparent */
	#bossImg { border-radius: 0 !important; box-shadow: none !important; background: transparent !important; width: 110px; height: 110px; }
	/* Boss hearts smaller to preserve space */
	#bossHearts img { width: 28px; height: 28px; margin: 0 3px; }

		.buzzer-effect {
			position: fixed;
			top: 0; left: 0; right: 0; bottom: 0;
			background: rgba(255, 59, 59, 0.25);
			pointer-events: none;
			z-index: 9999;
			animation: screenBuzz 0.4s linear 1;
		}
		@keyframes screenBuzz {
			0% { transform: translateX(0); }
			20% { transform: translateX(-16px); }
			40% { transform: translateX(16px); }
			60% { transform: translateX(-16px); }
			80% { transform: translateX(16px); }
			100% { transform: translateX(0); }
		}
		.duo-header {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 18px;
			margin-top: 32px;
			margin-bottom: 18px;
		}
		.duo-img {
			width: 64px;
			height: 64px;
			border-radius: 50%;
			background: #fff;
			box-shadow: 0 2px 8px #1e3c72;
		}
		.duo-title {
			font-size: 2.2rem;
			font-weight: 700;
			color: #4a90e2;
			font-family: 'Segoe UI', Arial, sans-serif;
			text-shadow: 0 2px 8px #222;
		}
		.quiz-progress {
			margin: 18px auto 0 auto;
			width: 80%;
			height: 18px;
			background: #232946;
			border-radius: 12px;
			overflow: hidden;
		}
		.quiz-progress-bar {
			height: 100%;
			background: linear-gradient(90deg, #4a90e2, #7f9cf5);
			width: 0%;
			border-radius: 12px;
			transition: width 0.3s;
		}
		.quiz-question {
			font-size: 1.6rem;
			font-weight: 700;
			/* tighter spacing so feedback appears just under the question */
			margin: 28px 0 6px 0;
			color: #f7f7fa;
			text-align: center;
			line-height: 1.3;
		}
		.quiz-answers {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
			/* keep answers closer to question and feedback */
			margin-top: 8px;
			margin-bottom: 36px;
			width: calc(100vw - 80px);
			max-width: calc(100vw - 80px);
			padding-left: 20px;
			padding-right: 20px;
		}
		.answer-btn-custom {
			width: 100%;
			min-width: 0;
			border-radius: 8px;
			font-size: 1.3rem;
			padding: 20px 16px;
			margin: 0;
			box-sizing: border-box;
			background: #232946;
			color: #f7f7fa;
			font-weight: 600;
			border-width: 3px;
			border-style: solid;
			transition: box-shadow 0.2s, transform 0.1s, border-color 0.2s;
			box-shadow: 0 4px 16px #23294655;
			min-height: 64px;
			position: relative;
			overflow: hidden;
			text-align: left;
		}
		.answer-btn-custom:hover {
			transform: scale(1.04);
			box-shadow: 0 8px 32px #23294699;
			opacity: 0.97;
		}
		.answer-fill {
			position: absolute;
			left: 0; bottom: 0;
			width: 100%;
			height: 0%;
			z-index: 1;
			transition: height 0.8s cubic-bezier(.4,1.6,.4,1);
		}
		.answer-btn-custom .answer-fill {
			border-radius: 0;
		}
		.answer-fill.c1 { background: linear-gradient(0deg, #e57373 80%, #ffb3b3 100%); }
		.answer-fill.c2 { background: linear-gradient(0deg, #64b5f6 80%, #b3e0ff 100%); }
		.answer-fill.c3 { background: linear-gradient(0deg, #81c784 80%, #c8e6c9 100%); }
		.answer-fill.c4 { background: linear-gradient(0deg, #ffd54f 80%, #fff9c4 100%); }
		.border-c1 { border-color: #e57373; }
		.border-c2 { border-color: #64b5f6; }
		.border-c3 { border-color: #81c784; }
		.border-c4 { border-color: #ffd54f; }
		.quiz-feedback {
			font-size: 1.1rem;
			font-weight: 500;
			color: #ffeb3b;
			margin: 6px 0 12px 0; /* small top margin so feedback sits just under the question */
			min-height: 24px;
			transition: color 0.2s;
			text-align: center;
		}
		.quiz-feedback.wrong {
			color: #ff3b3b;
			animation: buzz 0.3s linear 1;
		}
		@keyframes buzz {
			0% { transform: translateX(0); }
			20% { transform: translateX(-8px); }
			40% { transform: translateX(8px); }
			60% { transform: translateX(-8px); }
			80% { transform: translateX(8px); }
			100% { transform: translateX(0); }
		}
		.quiz-finish {
			font-size: 1.5rem;
			color: #4a90e2;
			font-weight: 700;
			margin-top: 24px;
		}

		/* center block for vertically centering question area */
		#quiz-center-block {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			/* slightly smaller min-height and a small upward nudge so the block sits higher */
			min-height: calc(54vh);
			transform: translateY(-3vh);
			width: 100%;
			box-sizing: border-box;
			padding: 8px 16px;
		}
	</style>
</head>
<body style="margin:0; padding:0; overflow-x:hidden; background:#232946;">
	<button id="pause-btn" style="position:fixed;top:24px;left:32px;z-index:1000;padding:12px 24px;font-size:1.4rem;border-radius:8px;background:#4a90e2;color:#fff;border:none;box-shadow:0 2px 8px #222;cursor:pointer;">&#124; &#124;</button>
	<div id="pause-modal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(30,30,50,0.85);z-index:2000;align-items:center;justify-content:center;">
		<div style="background:#fff;border-radius:18px;padding:40px 32px;box-shadow:0 8px 32px #23294699;min-width:280px;max-width:90vw;text-align:center;">
			<h2 style="color:#4a90e2;margin-bottom:24px;">Game Paused</h2>
			<button id="resume-btn" style="margin:12px 0 0 0;padding:12px 32px;font-size:1.1rem;border-radius:8px;background:#4a90e2;color:#fff;border:none;box-shadow:0 2px 8px #222;cursor:pointer;">Resume</button><br>
			<button id="restart-btn" style="margin:18px 0 0 0;padding:12px 32px;font-size:1.1rem;border-radius:8px;background:#ffd54f;color:#232946;border:none;box-shadow:0 2px 8px #222;cursor:pointer;">Restart</button><br>
			<button id="exit-btn" style="margin:18px 0 0 0;padding:12px 32px;font-size:1.1rem;border-radius:8px;background:#e57373;color:#fff;border:none;box-shadow:0 2px 8px #222;cursor:pointer;">Exit</button>
		</div>
	</div>
	<div class="duo-header">
		<img src="../../assets/images/Panda.png" alt="DuoLingo Panda" class="duo-img">
		<span class="duo-title">Challenger Quiz 25: Review</span>
	</div>
	<!-- Boss fight HUD -->
	<div style="display:flex;gap:28px;align-items:flex-end;justify-content:center;margin-top:12px;padding-bottom:1vh;">
		<div style="text-align:center;color:#fff;">
			<div style="font-weight:700;margin-bottom:6px;transform:translateY(12px);">You</div>
			<img id="playerImg" src="../../assets/images/Panda/Idle.png" alt="Player" width="180" height="180" style="width:180px;height:180px;border-radius:0;background:transparent;box-shadow:none;transform:translateY(6px);">
			<div id="playerHearts" style="display:flex;gap:6px;justify-content:center;margin-top:6px;align-items:center;">
				<!-- hearts rendered by updatePlayerHealthBar() -->
			</div>
		</div>
		<div style="text-align:center;color:#fff;">
			<div style="font-weight:700;margin-bottom:6px;">Boss</div>
			<img id="bossImg" src="../../assets/images/Master Boss/01_demon_idle/demon_idle_1.png" alt="Boss" width="450" height="250" style="width:450px;height:250px;border-radius:12px;box-shadow:0 8px 26px #0009;transform:translateY(10px) scaleX(1);">
			<div id="bossHealth" style="width:340px;margin:8px auto 0 auto;background:#333;border-radius:12px;padding:6px;box-sizing:border-box;">
				<div id="bossHealthBar" style="width:100%;height:18px;background:linear-gradient(90deg,#4a90e2,#7f9cf5);border-radius:8px;transition:width 0.25s;"></div>
			</div>
		</div>
	</div>
	<!-- center block keeps question/feedback/answers vertically centered inside viewport -->
	<div id="quiz-center-block">
		<div class="quiz-progress">
			<div class="quiz-progress-bar" id="quiz-progress-bar"></div>
		</div>
		<div class="quiz-question" id="quiz-question"></div>
		<div class="quiz-feedback" id="quiz-feedback"></div>
		<div class="quiz-answers" id="quiz-answers"></div>
	</div>
	<div id="buzzer-effect-root"></div>
	<script src="../../assets/js/master_boss_anim.js"></script>
	<script>

const originalQuestions = [
{ q: "Match the word: 仁", options: ["strategy / tactics", "military strategy", "general", "benevolence / kindness"], answer: 3 },
{ q: "Match the word: 礼", options: ["courage", "offense and defense", "ritual / propriety", "wisdom"], answer: 2 },
{ q: "Match the word: 智", options: ["know yourself and the enemy", "wisdom", "Sun Tzu", "benevolence / kindness"], answer: 1 },
{ q: "Match the word: 勇", options: ["strategy / tactics", "military strategy", "courage", "general"], answer: 2 },
{ q: "Match the word: 孙子", options: ["offense and defense", "ritual / propriety", "Sun Tzu", "wisdom"], answer: 2 },
{ q: "Match the word: 兵法", options: ["know yourself and the enemy", "military strategy", "benevolence / kindness", "strategy / tactics"], answer: 1 },
{ q: "Match the word: 谋略", options: ["strategy / tactics", "general", "courage", "offense and defense"], answer: 0 },
{ q: "Match the word: 上将", options: ["ritual / propriety", "general", "wisdom", "know yourself and the enemy"], answer: 1 },
{ q: "Match the word: 攻守", options: ["Sun Tzu", "offense and defense", "benevolence / kindness", "strategy / tactics"], answer: 1 },
{ q: "Match the word: 知己知彼", options: ["military strategy", "know yourself and the enemy", "general", "courage"], answer: 1 },
{ q: "___是儒家思想的重要原则。 (Benevolence)", options: ["仁", "礼", "智", "勇"], answer: 0 },
{ q: "用谋略来___敌人。 (defeat)", options: ["战胜", "支持", "反对", "总结"], answer: 0 },
{ q: "如果敌人强大，___采取防守策略。 (then)", options: ["就", "虽然", "既", "因为"], answer: 0 },
{ q: "___爱人。 (The benevolent person)", options: ["仁者", "智者", "勇者", "孙子"], answer: 0 },
{ q: "孙子写了___这本书。 (military strategy)", options: ["兵法", "谋略", "攻守", "上将"], answer: 0 },
{ q: "兵法强调___和防守的重要性。 (offense)", options: ["攻守", "仁", "礼", "智"], answer: 0 },
{ q: "___是智慧的象征。 (Wisdom)", options: ["智", "勇", "礼", "仁"], answer: 0 },
{ q: "将军是军队中的___。 (general)", options: ["上将", "孙子", "攻守", "谋略"], answer: 0 },
{ q: "___，百战不殆。 (know yourself and your enemy)", options: ["知己知彼", "仁", "礼", "智"], answer: 0 },
{ q: "___在古代战争中非常重要。 (Strategy / tactics)", options: ["谋略", "攻守", "仁", "礼"], answer: 0 },
{ q: "___是儒家思想的重要原则。 (Benevolence)", options: ["仁", "谋略", "就", "仁者"], answer: 0 },
{ q: "将军使用___来战胜敌人。 (strategy)", options: ["兵法", "谋略", "就", "仁者"], answer: 1 },
{ q: "如果敌人强大，___采取防守策略。 (then)", options: ["仁", "谋略", "就", "仁者"], answer: 2 },
{ q: "___爱人。 (Benevolent person)", options: ["仁", "谋略", "兵法", "仁者"], answer: 3 },
{ q: "孙子写了___这本书。 (military strategy)", options: ["兵法", "谋略", "就", "仁者"], answer: 0 },
{ q: "Benevolence is an important principle of Confucianism.  ______", options: ["仁是儒家思想的重要原则。", "将军使用谋略来战胜敌人。", "如果敌人强大，就采取防守策略。", "仁者爱人。"], answer: 0 },
{ q: "The general uses strategy to defeat the enemy.  ______", options: ["孙子写了《孙子兵法》。", "将军使用谋略来战胜敌人。", "如果敌人强大，就采取防守策略。", "仁者爱人。"], answer: 1 },
{ q: "If the enemy is strong, then adopt a defensive strategy.  ______", options: ["仁是儒家思想的重要原则。", "将军使用谋略来战胜敌人。", "如果敌人强大，就采取防守策略。", "仁者爱人。"], answer: 2 },
{ q: "The benevolent person loves others.  ______", options: ["仁是儒家思想的重要原则。", "将军使用谋略来战胜敌人。", "孙子写了《孙子兵法》。", "仁者爱人。"], answer: 3 },
{ q: "Sun Tzu wrote the book \"The Art of War.\"  ______", options: ["孙子写了《孙子兵法》。", "将军使用谋略来战胜敌人。", "如果敌人强大，就采取防守策略。", "仁者爱人。"], answer: 0 }
];

	const questions = [...originalQuestions];

	let current = 0;
	let score = 0;
	let paused = false;

	// Helper: Fisher-Yates shuffle - used to randomize option display order
	function shuffleArray(arr) {
		for (let i = arr.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[arr[i], arr[j]] = [arr[j], arr[i]];
		}
		return arr;
	}

	// Pause modal logic
	const pauseBtn = document.getElementById('pause-btn');
	const pauseModal = document.getElementById('pause-modal');
	const resumeBtn = document.getElementById('resume-btn');
	const restartBtn = document.getElementById('restart-btn');
	const exitBtn = document.getElementById('exit-btn');

	pauseBtn.onclick = function() {
		paused = true;
		pauseModal.style.display = 'flex';
	};
	resumeBtn.onclick = function() {
		paused = false;
		pauseModal.style.display = 'none';
	};
	restartBtn.onclick = function() {
		// Restart the boss fight and resume the game (hide pause modal)
		try {
			restartBossFight();
		} catch(e) {
			// fallback: basic reset
			playerHP = 100; bossHP = 100; current = 0; score = 0;
			updatePlayerHealthBar(); renderBossHeartsLocal();
			document.getElementById('quiz-feedback').textContent = '';
			showQuestion();
			document.getElementById('quiz-progress-bar').style.width = '0%';
		}
		// restore resume button and hide modal so game continues
		try { resumeBtn.style.display = ''; } catch(e){}
		try { paused = false; pauseModal.style.display = 'none'; } catch(e){}
};
	exitBtn.onclick = function() {
		window.location.href = '../levels/master.html';
	};

	function showQuestion() {
		if (originalQuestions.length === 0) {
			document.getElementById('quiz-question').innerHTML = 'Questions not yet added to this quiz.';
			document.getElementById('quiz-answers').innerHTML = '';
			document.getElementById('quiz-feedback').innerHTML = '<button onclick="window.location.href=\'../levels/rookie.html\'" style="padding:12px 32px;font-size:1.1rem;border-radius:8px;background:#4a90e2;color:#fff;border:none;box-shadow:0 2px 8px #222;cursor:pointer;">Back to Level</button>';
			return;
		}

		const q = questions[current];
		const questionDiv = document.getElementById('quiz-question');
		const answersDiv = document.getElementById('quiz-answers');
		questionDiv.innerHTML = q.q;
		answersDiv.innerHTML = '';

		// Shuffle options so the correct answer doesn't always appear in the same position
		try {
			const optionObjs = q.options.map((opt, i) => ({ text: opt, origIdx: i }));
			const shuffled = shuffleArray(optionObjs.slice());
			// store shuffled options and the displayed index of the correct answer
		q._shuffledOptions = shuffled;
		q._shuffledAnswerIdx = shuffled.findIndex(o => o.origIdx === q.answer);
		// debug: log shuffled order to console so you can verify visually
		try { console.log('shuffled options for question', current, shuffled.map(o => o.text)); } catch(e) {}
			shuffled.forEach((optObj, i) => {
				const btn = document.createElement('button');
				btn.className = `answer-btn-custom border-c${i + 1}`;
				btn.textContent = optObj.text;
				btn.onclick = () => checkAnswer(i);
				const fill = document.createElement('div');
				fill.className = `answer-fill c${i + 1}`;
				btn.appendChild(fill);
				answersDiv.appendChild(btn);
			});
		} catch (e) {
			// fallback: render in original order if anything goes wrong
			try { console.warn('shuffling options failed, rendering in original order', e); } catch(e) {}
			q.options.forEach((opt, i) => {
				const btn = document.createElement('button');
				btn.className = `answer-btn-custom border-c${i + 1}`;
				btn.textContent = opt;
				btn.onclick = () => checkAnswer(i);
				const fill = document.createElement('div');
				fill.className = `answer-fill c${i + 1}`;
				btn.appendChild(fill);
				answersDiv.appendChild(btn);
			});
		}
		document.getElementById('quiz-feedback').textContent = '';
		updateProgress();
	}

	// Boss fight state
	let playerHP = 100;
	// boss uses hit-count: 30 correct answers to defeat
	let bossHP = 30; // 30 hits required

	function renderBossHealthBar() {
		const bar = document.getElementById('bossHealthBar');
		if (!bar) return;
		const total = 30;
		const pct = Math.max(0, Math.min(100, (bossHP / total) * 100));
		bar.style.width = pct + '%';
		// change color as boss gets low
		if (pct > 60) bar.style.background = 'linear-gradient(90deg,#4a90e2,#7f9cf5)';
		else if (pct > 30) bar.style.background = 'linear-gradient(90deg,#ffd54f,#ffb74d)';
		else bar.style.background = 'linear-gradient(90deg,#ff6b6b,#ff3b3b)';
	}

	function updatePlayerHealthBar() {
		const container = document.getElementById('playerHearts');
		if (!container) return;
		container.innerHTML = '';
		const hearts = 5;
		const hpPerHeart = 100 / hearts; // 20
		for (let i = 0; i < hearts; i++) {
			const img = document.createElement('img');
			const filled = playerHP > i * hpPerHeart;
			img.src = filled ? '../../assets/images/Heart.png' : '../../assets/images/Emptyheart.png';
			img.style.width = '34px'; img.style.height = '34px'; img.style.margin = '0 4px';
			container.appendChild(img);
		}
	}

	function checkAnswer(idx) {
		if (paused) return;
		const q = questions[current];
		// prefer shuffled index when present
		const correctIdx = (typeof q._shuffledAnswerIdx === 'number') ? q._shuffledAnswerIdx : q.answer;
		if(idx === correctIdx) {
			// correct -> damage boss
			score++;
			// each correct hit counts as 1 toward the 30 required hits
			bossHP = Math.max(0, bossHP - 1);
				try {
					try { const b = window._masterBossSprite || window._challengerBossSprite || window._rookieBossSprite; if (b) { try { if (typeof b._stop === 'function') b._stop(); } catch(e){} try { b.takeHit(); } catch(e){} } } catch(e){}
				} catch(e){}
				// player does attack animation (right hook)
				try { if (window._rookiePlayerSprite) window._rookiePlayerSprite.attackRightHook(); } catch(e){}
			document.getElementById('quiz-feedback').innerHTML = '<span style="color:#ffe600;font-weight:700;font-size:1.5rem;display:inline-block;text-align:center;width:100%">Hit! Boss takes damage. <span style="font-size:1.5rem;">⚔️</span></span>';
			renderBossHealthBar();
			if (bossHP <= 0) {
				// boss defeated
				document.getElementById('quiz-feedback').innerHTML = '<span style="color:#4caf50;font-weight:800;font-size:1.6rem;display:inline-block;text-align:center;width:100%">Boss Defeated! 🏆</span>';
				try { const b = window._masterBossSprite || window._challengerBossSprite || window._rookieBossSprite; if (b && typeof b.die === 'function') b.die(); } catch(e){}
				// allow death animation to play then finish
				setTimeout(finishBossFight, 1400);
				return;
			}
			const answersDiv = document.getElementById('quiz-answers');
			const btns = answersDiv.querySelectorAll('.answer-btn-custom');
			const btn = btns[idx];
			const fill = btn.querySelector('.answer-fill');
			fill.style.height = '100%';
			btns.forEach(b => b.disabled = true);
			setTimeout(() => {
				if (!paused) nextQuestion();
			}, 850);
		} else {
			// wrong -> damage player
			playerHP = Math.max(0, playerHP - 20);
			try { const b = window._masterBossSprite || window._challengerBossSprite || window._rookieBossSprite; if (b && typeof b.attack === 'function') b.attack(); } catch(e){}
			// If player still has HP after this hit, play get-hit animation.
			// If playerHP reached 0 (last heart), play death spritesheet instead.
			try {
				if (playerHP > 0) {
					if (window._rookiePlayerSprite && typeof window._rookiePlayerSprite.playGetHit === 'function') {
						// small delay so the hit animation lines up with the boss attack animation
						setTimeout(function(){
							try { window._rookiePlayerSprite.playGetHit(600); } catch(e){}
						}, 220);
					}
				} else {
					// last heart -> play death spritesheet (delayed slightly to sync)
					setTimeout(function(){
						try {
							if (window._rookiePlayerSprite && typeof window._rookiePlayerSprite.playOneShotImage === 'function') {
								window._rookiePlayerSprite.playOneShotImage('../../assets/images/Panda/Death.png', 1200);
							}
						} catch(e) { console.warn('failed to play player death', e); }
					}, 220);
				}
			} catch(e){}
			updatePlayerHealthBar();
			const feedback = document.getElementById('quiz-feedback');
			feedback.innerHTML = '<span style="color:#ff3b3b;font-weight:700;font-size:1.5rem;display:inline-block;text-align:center;width:100%">Wrong! You take damage. <span style="font-size:1.5rem;">💥</span></span>';
			feedback.classList.add('wrong');
			const buzzerRoot = document.getElementById('buzzer-effect-root') || document.body;
			const buzzerDiv = document.createElement('div');
			buzzerDiv.className = 'buzzer-effect';
			// append to root that is outside the scaled wrapper so overlay covers the full viewport
			buzzerRoot.appendChild(buzzerDiv);
			setTimeout(() => {
				feedback.classList.remove('wrong');
				feedback.textContent = '';
				try { buzzerDiv.remove(); } catch(e) { if (buzzerDiv.parentNode) buzzerDiv.parentNode.removeChild(buzzerDiv); }
			}, 700);
			if (playerHP <= 0) {
				// player defeated
				document.getElementById('quiz-feedback').innerHTML = '<span style="color:#ff3b3b;font-weight:800;font-size:1.6rem;display:inline-block;text-align:center;width:100%">You were defeated! Try again.</span>';
				// play panda death spritesheet (if available) then show modal with only Restart and Exit
				try {
					if (window._rookiePlayerSprite && typeof window._rookiePlayerSprite.playOneShotImage === 'function') {
						// Death spritesheet path
						window._rookiePlayerSprite.playOneShotImage('../../assets/images/Panda/Death.png', 1200);
					}
				} catch(e) { console.warn('failed to play player death', e); }
				// show pause modal but hide Resume so player can only Restart or Exit
				setTimeout(function(){
					try { resumeBtn.style.display = 'none'; } catch(e){}
					paused = true;
					pauseModal.style.display = 'flex';
				}, 600);
				return;
			}
		}
	}

	function finishBossFight() {
		// unlock next level and show finish screen
		setUnlockedLevel(16); // unlock next level in rookie sequence
		document.getElementById('quiz-question').innerHTML = '';
		document.getElementById('quiz-answers').innerHTML = '';
		document.getElementById('quiz-feedback').innerHTML += `<div class='quiz-finish' style='margin-top:12px;'>Boss beaten!<br>Your score: ${score} / ${questions.length}<br><br><button id='nextLevelBtn' style='margin-top:18px;padding:12px 32px;font-size:1.1rem;border-radius:8px;background:#4a90e2;color:#fff;border:none;cursor:pointer;'>Next Level</button></div>`;
		setTimeout(function() {
			var btn = document.getElementById('nextLevelBtn');
			if (btn) btn.onclick = function() { window.location.href = 'rookie_quiz26.html'; };
		}, 100);
	}

	function restartBossFight() {
	// reset HP and restart
	playerHP = 100; bossHP = 30; score = 0; current = 0;
	updatePlayerHealthBar(); renderBossHealthBar();
		document.getElementById('quiz-feedback').textContent = '';
		showQuestion();
		try { const b = window._challengerBossSprite || window._rookieBossSprite; if (b && typeof b.idleStart === 'function') { b.idleStart(); } } catch(e){}
	}

	function nextQuestion() {
		current++;
		if(current < questions.length) {
			showQuestion();
		} else {
			finishQuiz();
		}
	}

	function updateProgress() {
		const bar = document.getElementById('quiz-progress-bar');
		bar.style.width = ((current / questions.length) * 100) + '%';
	}

	function setUnlockedLevel(level) {
		localStorage.setItem('rookieUnlockedLevel', String(level));
		// If logged in, update backend
		var username = localStorage.getItem('rookieUserId');
		if (username) {
			fetch('http://localhost:3000/api/updateProgress', {
				method: 'POST',
				headers: {'Content-Type': 'application/json'},
				body: JSON.stringify({ username, unlockedLevel: level })
			});
		}
	}

	function finishQuiz() {
		document.getElementById('quiz-question').innerHTML = '';
		document.getElementById('quiz-answers').innerHTML = '';
		// Ensure boss is removed/defeated when quiz finishes
		try { const b = window._challengerBossSprite || window._rookieBossSprite; if (b && typeof b.die === 'function') { b.die(); } } catch(e){}
		try { var bhbar = document.getElementById('bossHealthBar'); if (bhbar) { bhbar.style.width = '0%'; bhbar.style.background = 'linear-gradient(90deg,#ff6b6b,#ff3b3b)'; } } catch(e) {}
		document.getElementById('quiz-feedback').innerHTML = `<div class='quiz-finish'>Quiz Complete!<br>Your score: ${score} / ${questions.length}<br><br>🐼 Panda is proud of you!<br><button id='nextLevelBtn' style='margin-top:18px;padding:12px 32px;font-size:1.1rem;border-radius:8px;background:#4a90e2;color:#fff;border:none;box-shadow:0 2px 8px #222;cursor:pointer;'>Next Level</button></div>`;
		document.getElementById('quiz-progress-bar').style.width = '100%';
		setUnlockedLevel(16); // Unlock next level
		setTimeout(function() {
			var btn = document.getElementById('nextLevelBtn');
			if (btn) {
				btn.onclick = function() {
					window.location.href = 'rookie_quiz16.html';
				};
			}
		}, 100);
	}

		// Initialize quiz
		showQuestion();

		// Initialize boss sprite controller (prefer MasterBossSprite)
		try {
			if (typeof MasterBossSprite === 'function') {
				window._masterBossSprite = new MasterBossSprite('bossImg');
				try { renderBossHealthBar(); } catch(e){}
				try { updatePlayerHealthBar(); } catch(e){}
				if (window._masterBossSprite) window._masterBossSprite.idleStart();
			} else if (typeof ChallengerBossSprite === 'function') {
				window._challengerBossSprite = new ChallengerBossSprite('bossImg');
				try { renderBossHealthBar(); } catch(e){}
				try { updatePlayerHealthBar(); } catch(e){}
				if (window._challengerBossSprite) window._challengerBossSprite.idleStart();
			} else {
				window._rookieBossSprite = new RookieBossSprite('bossImg');
				renderBossHealthBar();
				updatePlayerHealthBar();
				if (window._rookieBossSprite) window._rookieBossSprite.idleStart();
			}

			// Player sprite controller that supports single-image spritesheets (frames left-to-right)
			(function(){
				function PlayerSprite(imgId) {
					this.origImg = document.getElementById(imgId);
					if (!this.origImg) { console.warn('Player sprite img not found:', imgId); return; }
					this.src = this.origImg.getAttribute('src') || '../../assets/images/Panda/Idle.png';
					this.frames = 1;
					this.currentFrame = 0;
					this.interval = 120; // ms per frame
					this._running = false;
					this._timer = null;
					this.canvas = null;
					// one-shot animation state (for attacks/hits that are spritesheets)
					this._oneShotTimer = null;
					this._oneShotInterval = null;
					this._oneShotRunning = false;
					this.imgLoader = new Image();
					var self = this;
					this.imgLoader.onload = function(){
						// detect spritesheet: if width > height and integer multiple, use frames = width/height
						var nw = self.imgLoader.naturalWidth, nh = self.imgLoader.naturalHeight;
						var approx = Math.round(nw / nh);
						if (approx >= 2 && Math.abs((nw / approx) - nh) < 2) {
							self.frames = approx;
						} else {
							self.frames = 1;
						}
						// create canvas to replace the original img for smoother frame cropping
						self.canvas = document.createElement('canvas');
						// preserve inline styles for size/transform
						self.canvas.style.cssText = self.origImg.style.cssText;
						// prefer computed style sizes so canvas matches visible size
						try {
							var cs = window.getComputedStyle(self.origImg);
							var cw = parseFloat(cs.width);
							var ch = parseFloat(cs.height);
							if (cw && ch) {
								self.canvas.width = Math.round(cw);
								self.canvas.height = Math.round(ch);
							} else {
								self.canvas.width = self.origImg.width || Math.round(self.origImg.getBoundingClientRect().width) || nh;
								self.canvas.height = self.origImg.height || Math.round(self.origImg.getBoundingClientRect().height) || nh;
							}
						} catch(e) {
							self.canvas.width = self.origImg.width || Math.round(self.origImg.getBoundingClientRect().width) || nh;
							self.canvas.height = self.origImg.height || Math.round(self.origImg.getBoundingClientRect().height) || nh;
						}
						self.ctx = self.canvas.getContext('2d');
						// replace DOM node
						try { self.origImg.parentNode.replaceChild(self.canvas, self.origImg); } catch(e){ console.warn('replaceChild failed', e); }
						// draw first frame
						self.drawFrame(0);
					};
					this.imgLoader.onerror = function(){ console.warn('Failed to load player sprite', self.src); };
					this.imgLoader.src = this.src;
				}

				PlayerSprite.prototype.drawFrame = function(i){
					if (!this.ctx || !this.imgLoader) return;
					var sw = this.imgLoader.naturalWidth;
					var sh = this.imgLoader.naturalHeight;
					var frames = this.frames || 1;
					var fw = Math.floor(sw / frames);
					var fh = sh;
					var sx = i * fw;
					this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
					this.ctx.drawImage(this.imgLoader, sx, 0, fw, fh, 0, 0, this.canvas.width, this.canvas.height);
				};

				PlayerSprite.prototype._step = function(){
					this.currentFrame = (this.currentFrame + 1) % this.frames;
					this.drawFrame(this.currentFrame);
				};

				PlayerSprite.prototype.idleStart = function(){
					var self = this;
					if (this._running) return;
					this._running = true;
					// if frames == 1, keep single frame; otherwise animate
					if (this.frames <= 1) return;
					this._timer = setInterval(function(){ self._step(); }, this.interval);
				};

				PlayerSprite.prototype.idleStop = function(){
					if (this._timer) { clearInterval(this._timer); this._timer = null; }
					this._running = false;
				};

				// Play a single-image one-shot animation (draw image then revert to idle)
				PlayerSprite.prototype.playOneShotImage = function(imgPath, ms) {
					var self = this;
					try {
						// stop any idle animation and any running one-shot
						this.idleStop();
						if (this._oneShotTimer) { clearInterval(this._oneShotTimer); this._oneShotTimer = null; }
						this._oneShotRunning = false;

						var one = new Image();
						one.onload = function(){
							if (!self.ctx) return;
							var nw = one.naturalWidth, nh = one.naturalHeight;
							// detect horizontal spritesheet (frames left-to-right)
							var approx = Math.round(nw / nh) || 1;
							var isSheet = approx >= 2 && Math.abs((nw / approx) - nh) < 4;
							if (!isSheet) {
								// single image: draw and resume idle after ms
								self.ctx.clearRect(0,0,self.canvas.width,self.canvas.height);
								self.ctx.drawImage(one, 0, 0, nw, nh, 0, 0, self.canvas.width, self.canvas.height);
								setTimeout(function(){ try { self.idleStart(); } catch(e){} }, ms || 700);
								return;
							}

							// spritesheet case: play frames once
							var frames = approx;
							var fw = Math.floor(nw / frames);
							var fh = nh;
							var totalMs = ms || Math.max(80 * frames, 400);
							var frameMs = Math.max(40, Math.round(totalMs / frames));
							var idx = 0;
							self._oneShotRunning = true;
							// draw first frame
							self.ctx.clearRect(0,0,self.canvas.width,self.canvas.height);
							self.ctx.drawImage(one, 0, 0, fw, fh, 0, 0, self.canvas.width, self.canvas.height);
							// step through remaining frames
							self._oneShotTimer = setInterval(function(){
								idx++;
								if (idx >= frames) {
									// finished
									clearInterval(self._oneShotTimer);
									self._oneShotTimer = null;
									self._oneShotRunning = false;
									try { self.idleStart(); } catch(e){}
									return;
								}
								var sx = idx * fw;
								self.ctx.clearRect(0,0,self.canvas.width,self.canvas.height);
								self.ctx.drawImage(one, sx, 0, fw, fh, 0, 0, self.canvas.width, self.canvas.height);
							}, frameMs);
						};
						one.onerror = function(){ console.warn('failed to load one-shot', imgPath); try { self.idleStart(); } catch(e){} };
						one.src = imgPath;
					} catch (e) { console.warn('playOneShotImage failed', e); try { this.idleStart(); } catch(e){} }
				};

				// Attack: right hook (uses separate image file)
				PlayerSprite.prototype.attackRightHook = function() {
					// path to the right hook image
					var path = '../../assets/images/Panda/RightHook.png';
					this.playOneShotImage(path, 800);
				};

				// Play 'get hit' one-shot spritesheet
				PlayerSprite.prototype.playGetHit = function(ms) {
					var path = '../../assets/images/Panda/Hit.png';
					this.playOneShotImage(path, ms || 500);
				};

				window.RookiePlayerSprite = PlayerSprite;
			})();

			// initialize player sprite on the small player img (first matching img in HUD)
			try {
				var pImg = document.querySelector('img[alt="Player"]');
				// ensure the player element uses the Panda spritesheet (left-to-right frames)
				if (pImg) {
					if (!pImg.id) pImg.id = 'playerImg';
					// set spritesheet source explicitly so the PlayerSprite can detect frames
					pImg.src = '../../assets/images/Panda/Idle.png';
				}
				if (window.RookiePlayerSprite) {
					window._rookiePlayerSprite = new window.RookiePlayerSprite('playerImg');
					// wait briefly for loader to initialize canvas, then start idle loop
					setTimeout(function(){ try { if (window._rookiePlayerSprite) window._rookiePlayerSprite.idleStart(); } catch(e){} }, 160);
				}
			} catch(e) { console.warn('Player sprite init failed', e); }
		} catch (e) {
			console.warn('Boss sprite init failed', e);
		}

// Fit-to-viewport scaler (taskbar-aware)
(function(){
	function getAvailableHeight(){
		// Use screen.availHeight when available (excludes taskbar on many systems). Fallback to window.innerHeight.
		try { if (window.screen && window.screen.availHeight) return window.screen.availHeight; } catch(e){}
		return window.innerHeight;
	}
	function wrapAndScale(){
		const root = document.body; // page roots differ; using body ensures we cover all content
		if (!root) return;
			if (!document.getElementById('quiz-wrap')) {
				const wrap = document.createElement('div');
				wrap.id = 'quiz-wrap';
				wrap.style.width = '100%';
				wrap.style.transformOrigin = 'top center';
				wrap.style.willChange = 'transform';
				// keep pause controls and the buzzer root outside the scaled wrapper so fixed overlays cover the viewport
				const keepIds = ['pause-btn','pause-modal','buzzer-effect-root'];
				const nodes = Array.from(root.childNodes);
				nodes.forEach(n => {
					if (n.id && keepIds.includes(n.id)) return;
					wrap.appendChild(n);
				});
				root.appendChild(wrap);
			}
		const wrapEl = document.getElementById('quiz-wrap');
		if (!wrapEl) return;
		wrapEl.style.transform = 'none';
		// measure content height
		const contentH = wrapEl.scrollHeight || wrapEl.offsetHeight || wrapEl.getBoundingClientRect().height;
		const viewH = getAvailableHeight();
		let scale = 1;
		const minScale = 0.85;
		scale = Math.min(1, viewH / contentH);
		if (scale < minScale) scale = minScale;
		wrapEl.style.transform = 'scale(' + scale + ')';
		wrapEl.style.marginTop = Math.max(0, (viewH - (contentH * scale)) / 2) + 'px';
		// set debug overlay values if present
		const dbgScale = document.getElementById('dbg-scale');
		const q = document.querySelector('.quiz-question');
		if (dbgScale) dbgScale.textContent = 'scale: ' + scale.toFixed(3);
		const dbgQfs = document.getElementById('dbg-qfs');
		if (dbgQfs && q) dbgQfs.textContent = 'q font: ' + window.getComputedStyle(q).fontSize;
	}
	window.wrapAndScale = wrapAndScale; // expose for debug button
	window.addEventListener('load', wrapAndScale);
	window.addEventListener('resize', function(){ setTimeout(wrapAndScale,40); });
	setTimeout(wrapAndScale,80);
})();

// debug overlay removed
	</script>
</body>
</html>